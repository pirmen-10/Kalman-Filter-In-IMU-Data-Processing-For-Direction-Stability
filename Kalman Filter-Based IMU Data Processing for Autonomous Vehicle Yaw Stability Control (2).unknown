{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "99441641-8ca3-499b-ae75-9951986673ef",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import board\n",
    "import busio\n",
    "import adafruit_bno055\n",
    "import time\n",
    "import pickle\n",
    "from jetracer.nvidia_racecar import NvidiaRacecar\n",
    "\n",
    "# Inisialisasi IMU BNO055 dengan I2C\n",
    "i2c = busio.I2C(board.SCL_1, board.SDA_1)\n",
    "sensor = adafruit_bno055.BNO055_I2C(i2c)\n",
    "time.sleep(0.25)\n",
    "\n",
    "# Inisialisasi mobil JetRacer\n",
    "car = NvidiaRacecar()\n",
    "car.steering_gain = 0.4\n",
    "car.throttle_gain = 0.4\n",
    "car.throttle = -0.4\n",
    "car.steering = 0\n",
    "\n",
    "# Buffer untuk gyro smoothing dan outlier detection\n",
    "gyro_buffer = []\n",
    "previous_gyro_z = None\n",
    "change_threshold = 5\n",
    "\n",
    "def normalize_angle(angle):\n",
    "    return ((angle + 180) % 360) - 180\n",
    "\n",
    "def angle_difference(angle1, angle2):\n",
    "    diff = angle1 - angle2\n",
    "    return normalize_angle(diff)\n",
    "\n",
    "class ImprovedKalmanFilter:\n",
    "    def __init__(self, dt=0.05, process_noise_yaw=1e-5, process_noise_bias=1e-6, \n",
    "                 measurement_noise_yaw=1e-4, measurement_noise_gyro=5e-2):\n",
    "        self.dt = dt\n",
    "        self.x = np.array([[0.0], [0.0], [0.0]])  # [yaw, yaw_rate, bias]\n",
    "        self.F = np.array([\n",
    "            [1, dt, 0],\n",
    "            [0, 1, 0],\n",
    "            [0, 0, 1]\n",
    "        ])\n",
    "        self.H = np.array([\n",
    "            [1, 0, 0],\n",
    "            [0, 1, -1]\n",
    "        ])\n",
    "        self.Q = np.array([\n",
    "            [process_noise_yaw * dt**2, 0, 0],\n",
    "            [0, process_noise_yaw, 0],\n",
    "            [0, 0, process_noise_bias]\n",
    "        ])\n",
    "        self.R = np.array([\n",
    "            [measurement_noise_yaw, 0],\n",
    "            [0, measurement_noise_gyro]\n",
    "        ])\n",
    "        self.P = np.eye(3) * 10\n",
    "\n",
    "    def predict(self):\n",
    "        self.x = np.dot(self.F, self.x)\n",
    "        self.x[0, 0] = normalize_angle(self.x[0, 0])\n",
    "        self.P = np.dot(np.dot(self.F, self.P), self.F.T) + self.Q\n",
    "        return self.x[0, 0]\n",
    "    \n",
    "    def update(self, yaw_measured, gyro_z):\n",
    "        yaw_measured = normalize_angle(yaw_measured)\n",
    "        z_pred = np.dot(self.H, self.x)\n",
    "        z = np.array([[yaw_measured], [gyro_z]])\n",
    "        innovation = z - z_pred\n",
    "        innovation[0, 0] = angle_difference(yaw_measured, z_pred[0, 0])\n",
    "        S = np.dot(self.H, np.dot(self.P, self.H.T)) + self.R\n",
    "        K = np.dot(np.dot(self.P, self.H.T), np.linalg.inv(S))\n",
    "        self.x = self.x + np.dot(K, innovation)\n",
    "        self.x[0, 0] = normalize_angle(self.x[0, 0])\n",
    "        I = np.eye(self.P.shape[0])\n",
    "        self.P = np.dot(I - np.dot(K, self.H), self.P)\n",
    "        return self.x[0, 0], self.x[1, 0], self.x[2, 0]\n",
    "\n",
    "def calculate_steering_raw_imu(yaw_raw, gyro_z_processed, target_yaw, current_time):\n",
    "    \"\"\"Hitung steering berdasarkan raw IMU tanpa Kalman filter\"\"\"\n",
    "    if current_time <= 1.0:\n",
    "        return 0, 0, 0\n",
    "    \n",
    "    yaw_error = angle_difference(target_yaw, yaw_raw)\n",
    "    abs_error = abs(yaw_error)\n",
    "    \n",
    "    KP_BASE = 3\n",
    "    if abs_error < 5:\n",
    "        kp = KP_BASE * 1.5\n",
    "    elif abs_error < 15:\n",
    "        kp = KP_BASE\n",
    "    else:\n",
    "        kp = KP_BASE * 0.7\n",
    "    \n",
    "    SMART_DEADZONE = 0.05\n",
    "    if abs(yaw_error) < SMART_DEADZONE and abs(gyro_z_processed) < 2.0:\n",
    "        yaw_correction = 0\n",
    "    else:\n",
    "        effective_error = yaw_error - np.sign(yaw_error) * SMART_DEADZONE if abs(yaw_error) > SMART_DEADZONE else yaw_error\n",
    "        yaw_correction = kp * effective_error / 45\n",
    "    \n",
    "    KD = 0.6\n",
    "    yaw_rate_damping = -KD * gyro_z_processed / 30\n",
    "    \n",
    "    steering_raw = yaw_correction + yaw_rate_damping\n",
    "    steering_final = np.clip(steering_raw, -1, 1)\n",
    "    \n",
    "    return steering_final, yaw_error, gyro_z_processed\n",
    "\n",
    "# Inisialisasi sistem\n",
    "kf = ImprovedKalmanFilter()\n",
    "TARGET_YAW = 0\n",
    "\n",
    "# Parameter kontrol\n",
    "KP_BASE = 3.75\n",
    "KD = 0.6\n",
    "MAX_STEERING = 1\n",
    "\n",
    "# Data logging\n",
    "data_log = {\n",
    "    'time_list': [],\n",
    "    'yaw_raw_list': [],\n",
    "    'gyro_z_list': [],\n",
    "    'gyro_processed_list': [],\n",
    "    'yaw_pred_list': [],\n",
    "    'yaw_filtered_list': [],\n",
    "    'yaw_rate_list': [],\n",
    "    'yaw_error_list': [],\n",
    "    'steering_list': [],\n",
    "    'steering_raw_imu_list': [],\n",
    "    'yaw_error_raw_list': [],\n",
    "    'yaw_rate_raw_list': []\n",
    "}\n",
    "\n",
    "start_time = time.time()\n",
    "\n",
    "try:\n",
    "    print(\"Starting dual processing control system...\")\n",
    "    print(\"Path 1: Kalman Filter processing (active control)\")\n",
    "    print(\"Path 2: Raw IMU processing (comparison)\")\n",
    "    print(\"Press Ctrl+C to stop\")\n",
    "    \n",
    "    while True:\n",
    "        yaw_raw = sensor.euler[0]\n",
    "        gyro_z = np.degrees(sensor.gyro[2])\n",
    "\n",
    "        if yaw_raw is None or gyro_z is None or np.isnan(yaw_raw) or np.isnan(gyro_z):\n",
    "            continue\n",
    "\n",
    "        # Gyro smoothing dan outlier detection\n",
    "        gyro_buffer.append(gyro_z)\n",
    "        \n",
    "        if len(gyro_buffer) > 3:\n",
    "            gyro_buffer.pop(0)\n",
    "        \n",
    "        gyro_z_avg = np.mean(gyro_buffer)\n",
    "\n",
    "        if previous_gyro_z is not None:\n",
    "            gyro_change = abs(gyro_z - previous_gyro_z)\n",
    "            if gyro_change > change_threshold:\n",
    "                gyro_z_to_use = gyro_z\n",
    "                print(f\"Outlier detected: gyro change = {gyro_change:.1f}°/s\")\n",
    "            else:\n",
    "                gyro_z_to_use = gyro_z_avg\n",
    "        else:\n",
    "            gyro_z_to_use = gyro_z\n",
    "\n",
    "        current_time = time.time() - start_time\n",
    "\n",
    "        # PATH 1: KALMAN FILTER PROCESSING (mengontrol mobil)\n",
    "        yaw_predicted = kf.predict()\n",
    "        yaw_filtered, yaw_rate_filtered, gyro_bias = kf.update(yaw_raw, gyro_z_to_use)\n",
    "\n",
    "        # Kontrol aktif setelah settling time\n",
    "        if current_time > 1.0:\n",
    "            yaw_error = angle_difference(TARGET_YAW, yaw_filtered)\n",
    "            abs_error = abs(yaw_error)\n",
    "\n",
    "            # Adaptive gain\n",
    "            if abs_error < 5:\n",
    "                kp = KP_BASE * 1.5\n",
    "            elif abs_error < 15:\n",
    "                kp = KP_BASE\n",
    "            else:\n",
    "                kp = KP_BASE * 0.7\n",
    "\n",
    "            # Smart deadzone\n",
    "            SMART_DEADZONE = 0.05\n",
    "            \n",
    "            if abs(yaw_error) < SMART_DEADZONE and abs(yaw_rate_filtered) < 2.0:\n",
    "                yaw_correction = 0\n",
    "            else:\n",
    "                effective_error = yaw_error - np.sign(yaw_error) * SMART_DEADZONE if abs(yaw_error) > SMART_DEADZONE else yaw_error\n",
    "                yaw_correction = kp * effective_error / 45\n",
    "            \n",
    "            # Yaw rate damping\n",
    "            yaw_rate_damping = -KD * yaw_rate_filtered / 30\n",
    "            \n",
    "            steering_raw = yaw_correction + yaw_rate_damping\n",
    "            steering_command = np.clip(steering_raw, -MAX_STEERING, MAX_STEERING)\n",
    "            \n",
    "            car.steering = steering_command\n",
    "\n",
    "        else:\n",
    "            yaw_error = 0\n",
    "            steering_command = 0\n",
    "            car.steering = 0\n",
    "\n",
    "        # PATH 2: RAW IMU PROCESSING (untuk perbandingan)\n",
    "        steering_raw_imu, yaw_error_raw, yaw_rate_raw = calculate_steering_raw_imu(\n",
    "            yaw_raw, gyro_z_to_use, TARGET_YAW, current_time)\n",
    "\n",
    "        # Data logging\n",
    "        data_log['time_list'].append(current_time)\n",
    "        data_log['yaw_raw_list'].append(yaw_raw)\n",
    "        data_log['gyro_z_list'].append(gyro_z)\n",
    "        data_log['gyro_processed_list'].append(gyro_z_to_use)\n",
    "        data_log['yaw_pred_list'].append(yaw_predicted)\n",
    "        data_log['yaw_filtered_list'].append(yaw_filtered)\n",
    "        data_log['yaw_rate_list'].append(yaw_rate_filtered if current_time > 1.0 else 0)\n",
    "        data_log['yaw_error_list'].append(yaw_error)\n",
    "        data_log['steering_list'].append(steering_command)\n",
    "        data_log['steering_raw_imu_list'].append(steering_raw_imu)\n",
    "        data_log['yaw_error_raw_list'].append(yaw_error_raw)\n",
    "        data_log['yaw_rate_raw_list'].append(yaw_rate_raw)\n",
    "\n",
    "        # Status output\n",
    "        if len(data_log['time_list']) % 20 == 0:\n",
    "            mode = \"SETTLING\" if current_time <= 1.0 else \"ACTIVE\"\n",
    "            print(f'T:{current_time:.1f}s | Raw:{yaw_raw:.1f}° | Filt:{yaw_filtered:.1f}° | '\n",
    "                  f'Rate:{yaw_rate_filtered:.1f}°/s | Err_K:{yaw_error:.1f}° | Err_R:{yaw_error_raw:.1f}° | '\n",
    "                  f'Str_K:{steering_command:.2f} | Str_R:{steering_raw_imu:.2f} | {mode}')\n",
    "\n",
    "        previous_gyro_z = gyro_z\n",
    "        time.sleep(0.007)\n",
    "\n",
    "except KeyboardInterrupt:\n",
    "    print(\"\\nProgram terminated.\")\n",
    "    car.throttle = 0\n",
    "    car.steering = 0\n",
    "    \n",
    "    # Simpan data untuk analisis\n",
    "    with open('jetracer_data.pkl', 'wb') as f:\n",
    "        pickle.dump(data_log, f)\n",
    "    \n",
    "    print(\"Data telah disimpan ke 'jetracer_data.pkl'\")\n",
    "    print(\"Jalankan 'jetracer_analysis.py' untuk melihat analisis lengkap\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5ef85b9b-3c57-4558-887b-10fa2e85fcdf",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import pickle\n",
    "\n",
    "def load_data(filename='jetracer_data.pkl'):\n",
    "    \"\"\"Load data dari file pickle\"\"\"\n",
    "    try:\n",
    "        with open(filename, 'rb') as f:\n",
    "            data_log = pickle.load(f)\n",
    "        print(f\"Data berhasil dimuat dari '{filename}'\")\n",
    "        return data_log\n",
    "    except FileNotFoundError:\n",
    "        print(f\"File '{filename}' tidak ditemukan!\")\n",
    "        return None\n",
    "\n",
    "def create_plots(data_log):\n",
    "    \"\"\"Buat plot analisis lengkap\"\"\"\n",
    "    # Extract data\n",
    "    time_list = data_log['time_list']\n",
    "    yaw_raw_list = data_log['yaw_raw_list']\n",
    "    gyro_z_list = data_log['gyro_z_list']\n",
    "    gyro_processed_list = data_log['gyro_processed_list']\n",
    "    yaw_pred_list = data_log['yaw_pred_list']\n",
    "    yaw_filtered_list = data_log['yaw_filtered_list']\n",
    "    yaw_rate_list = data_log['yaw_rate_list']\n",
    "    yaw_error_list = data_log['yaw_error_list']\n",
    "    steering_list = data_log['steering_list']\n",
    "    steering_raw_imu_list = data_log['steering_raw_imu_list']\n",
    "    yaw_error_raw_list = data_log['yaw_error_raw_list']\n",
    "    yaw_rate_raw_list = data_log['yaw_rate_raw_list']\n",
    "    \n",
    "    TARGET_YAW = 0\n",
    "    MAX_STEERING = 1\n",
    "    \n",
    "    plt.figure(figsize=(16, 18))\n",
    "    \n",
    "    # Plot 1: Yaw comparison\n",
    "    plt.subplot(7, 1, 1)\n",
    "    plt.plot(time_list, yaw_raw_list, 'b-', linewidth=1, \n",
    "             label='Yaw Raw IMU', alpha=0.7)\n",
    "    plt.plot(time_list, yaw_filtered_list, 'r-', linewidth=2, \n",
    "             label='Yaw Kalman Filtered')\n",
    "    plt.axhline(y=TARGET_YAW, color='green', linestyle='--', linewidth=2, \n",
    "                label='Target')\n",
    "    plt.axvline(x=1.0, color='orange', linestyle=':', alpha=0.7, \n",
    "                label='Control Start')\n",
    "    plt.ylabel('Yaw (°)')\n",
    "    plt.title('Dual Processing: Raw IMU vs Kalman Filtered Yaw')\n",
    "    plt.legend()\n",
    "    plt.grid(True, alpha=0.3)\n",
    "    \n",
    "    # Plot 2: Gyro processing\n",
    "    plt.subplot(7, 1, 2)\n",
    "    plt.plot(time_list, gyro_z_list, 'cyan', linewidth=1, \n",
    "             label='Gyro Raw', alpha=0.7)\n",
    "    plt.plot(time_list, gyro_processed_list, 'blue', linewidth=2, \n",
    "             label='Gyro Processed')\n",
    "    plt.ylabel('Gyro Z (°/s)')\n",
    "    plt.title('Gyro Processing: Raw vs Processed')\n",
    "    plt.legend()\n",
    "    plt.grid(True, alpha=0.3)\n",
    "    \n",
    "    # Plot 3: Yaw Rate Comparison\n",
    "    plt.subplot(7, 1, 3)\n",
    "    plt.plot(time_list, yaw_rate_raw_list, 'orange', linewidth=2, \n",
    "             label='Yaw Rate Raw', alpha=0.8)\n",
    "    plt.plot(time_list, yaw_rate_list, 'purple', linewidth=2, \n",
    "             label='Yaw Rate Kalman')\n",
    "    plt.axhline(y=0, color='black', linestyle='-', alpha=0.5)\n",
    "    plt.axvline(x=1.0, color='orange', linestyle=':', alpha=0.7)\n",
    "    plt.ylabel('Yaw Rate (°/s)')\n",
    "    plt.title('Yaw Rate: Raw vs Kalman Estimation')\n",
    "    plt.legend()\n",
    "    plt.grid(True, alpha=0.3)\n",
    "    \n",
    "    # Plot 4: Error Comparison\n",
    "    plt.subplot(7, 1, 4)\n",
    "    plt.plot(time_list, yaw_error_raw_list, 'orange', linewidth=2, \n",
    "             label='Error Raw IMU', alpha=0.8)\n",
    "    plt.plot(time_list, yaw_error_list, 'red', linewidth=2, \n",
    "             label='Error Kalman Filter')\n",
    "    plt.axhline(y=0, color='green', linestyle='-', alpha=0.5)\n",
    "    plt.axhline(y=5, color='gray', linestyle='--', alpha=0.7, label='±5°')\n",
    "    plt.axhline(y=-5, color='gray', linestyle='--', alpha=0.7)\n",
    "    plt.axvline(x=1.0, color='orange', linestyle=':', alpha=0.7)\n",
    "    plt.ylabel('Error (°)')\n",
    "    plt.title('Error Comparison: Raw IMU vs Kalman Filter')\n",
    "    plt.legend()\n",
    "    plt.grid(True, alpha=0.3)\n",
    "    \n",
    "    # Plot 5: STEERING COMPARISON\n",
    "    plt.subplot(7, 1, 5)\n",
    "    plt.plot(time_list, steering_raw_imu_list, 'orange', linewidth=2, \n",
    "             label='Steering Raw IMU', alpha=0.8)\n",
    "    plt.plot(time_list, steering_list, 'darkgreen', linewidth=2, \n",
    "             label='Steering Kalman Filter (AKTIF)')\n",
    "    plt.axhline(y=0, color='black', linestyle='-', alpha=0.5)\n",
    "    plt.axhline(y=MAX_STEERING, color='red', linestyle='--', alpha=0.7, \n",
    "                label=f'Max Steering (±{MAX_STEERING})')\n",
    "    plt.axhline(y=-MAX_STEERING, color='red', linestyle='--', alpha=0.7)\n",
    "    plt.axvline(x=1.0, color='orange', linestyle=':', alpha=0.7)\n",
    "    plt.ylabel('Steering Value')\n",
    "    plt.title('STEERING COMPARISON: Raw IMU vs Kalman Filter')\n",
    "    plt.legend()\n",
    "    plt.grid(True, alpha=0.3)\n",
    "    \n",
    "    # Plot 6: Steering Difference\n",
    "    steering_diff = [steering_list[i] - steering_raw_imu_list[i] for i in range(len(steering_list))]\n",
    "    plt.subplot(7, 1, 6)\n",
    "    plt.plot(time_list, steering_diff, 'red', linewidth=2, \n",
    "             label='Steering Difference (Kalman - Raw)')\n",
    "    plt.axhline(y=0, color='black', linestyle='-', alpha=0.5)\n",
    "    plt.axvline(x=1.0, color='orange', linestyle=':', alpha=0.7)\n",
    "    plt.ylabel('Steering Difference')\n",
    "    plt.title('Steering Difference Analysis')\n",
    "    plt.legend()\n",
    "    plt.grid(True, alpha=0.3)\n",
    "    \n",
    "    # Plot 7: Performance Metrics\n",
    "    plt.subplot(7, 1, 7)\n",
    "    abs_error_kalman = [abs(e) for e in yaw_error_list]\n",
    "    abs_error_raw = [abs(e) for e in yaw_error_raw_list]\n",
    "    plt.plot(time_list, abs_error_raw, 'orange', linewidth=2, \n",
    "             label='|Error| Raw IMU', alpha=0.8)\n",
    "    plt.plot(time_list, abs_error_kalman, 'red', linewidth=2, \n",
    "             label='|Error| Kalman Filter')\n",
    "    plt.axvline(x=1.0, color='orange', linestyle=':', alpha=0.7)\n",
    "    plt.xlabel('Time (s)')\n",
    "    plt.ylabel('|Error| (°)')\n",
    "    plt.title('Absolute Error Comparison')\n",
    "    plt.legend()\n",
    "    plt.grid(True, alpha=0.3)\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    return plt\n",
    "\n",
    "def analyze_performance(data_log):\n",
    "    \"\"\"Analisis performa lengkap\"\"\"\n",
    "    # Extract data\n",
    "    time_list = data_log['time_list']\n",
    "    yaw_error_list = data_log['yaw_error_list']\n",
    "    steering_list = data_log['steering_list']\n",
    "    yaw_rate_list = data_log['yaw_rate_list']\n",
    "    yaw_error_raw_list = data_log['yaw_error_raw_list']\n",
    "    steering_raw_imu_list = data_log['steering_raw_imu_list']\n",
    "    yaw_rate_raw_list = data_log['yaw_rate_raw_list']\n",
    "    \n",
    "    print(\"\\n\" + \"=\"*80)\n",
    "    print(\"ANALISIS PERFORMA DUAL PROCESSING\")\n",
    "    print(\"=\"*80)\n",
    "    \n",
    "    # Filter data setelah settling time\n",
    "    active_indices = [i for i, t in enumerate(time_list) if t > 1.0]\n",
    "    if len(active_indices) > 0:\n",
    "        # Data Kalman Filter\n",
    "        active_errors_kalman = [yaw_error_list[i] for i in active_indices]\n",
    "        active_steering_kalman = [steering_list[i] for i in active_indices]\n",
    "        active_yaw_rates_kalman = [yaw_rate_list[i] for i in active_indices]\n",
    "        \n",
    "        # Data Raw IMU\n",
    "        active_errors_raw = [yaw_error_raw_list[i] for i in active_indices]\n",
    "        active_steering_raw = [steering_raw_imu_list[i] for i in active_indices]\n",
    "        active_yaw_rates_raw = [yaw_rate_raw_list[i] for i in active_indices]\n",
    "        \n",
    "        # Analisis steering difference\n",
    "        active_steering_diff = [steering_list[i] - steering_raw_imu_list[i] for i in active_indices]\n",
    "        \n",
    "        # Statistik error\n",
    "        rmse_kalman = np.sqrt(np.mean([e**2 for e in active_errors_kalman]))\n",
    "        rmse_raw = np.sqrt(np.mean([e**2 for e in active_errors_raw]))\n",
    "        mae_kalman = np.mean([abs(e) for e in active_errors_kalman])\n",
    "        mae_raw = np.mean([abs(e) for e in active_errors_raw])\n",
    "        \n",
    "        # Analisis stabilitas\n",
    "        excellent_time_kalman = sum(1 for e in active_errors_kalman if abs(e) < 1.0) / len(active_errors_kalman) * 100\n",
    "        excellent_time_raw = sum(1 for e in active_errors_raw if abs(e) < 1.0) / len(active_errors_raw) * 100\n",
    "        \n",
    "        poor_time_kalman = sum(1 for e in active_errors_kalman if abs(e) > 5.0) / len(active_errors_kalman) * 100\n",
    "        poor_time_raw = sum(1 for e in active_errors_raw if abs(e) > 5.0) / len(active_errors_raw) * 100\n",
    "        \n",
    "        # Analisis smoothness steering\n",
    "        steering_smoothness_kalman = np.std(active_steering_kalman)\n",
    "        steering_smoothness_raw = np.std(active_steering_raw)\n",
    "        \n",
    "        print(f\"PERFORMA TRACKING:\")\n",
    "        print(f\"  KALMAN FILTER:\")\n",
    "        print(f\"    RMSE: {rmse_kalman:.2f}°\")\n",
    "        print(f\"    MAE: {mae_kalman:.2f}°\")\n",
    "        print(f\"    Waktu excellent (<1°): {excellent_time_kalman:.1f}%\")\n",
    "        print(f\"    Waktu poor (>5°): {poor_time_kalman:.1f}%\")\n",
    "        \n",
    "        print(f\"  RAW IMU:\")\n",
    "        print(f\"    RMSE: {rmse_raw:.2f}°\")\n",
    "        print(f\"    MAE: {mae_raw:.2f}°\")\n",
    "        print(f\"    Waktu excellent (<1°): {excellent_time_raw:.1f}%\")\n",
    "        print(f\"    Waktu poor (>5°): {poor_time_raw:.1f}%\")\n",
    "        \n",
    "        print(f\"\\nANALISIS IMPROVEMENT:\")\n",
    "        rmse_improvement = ((rmse_raw - rmse_kalman) / rmse_raw) * 100 if rmse_raw != 0 else 0\n",
    "        mae_improvement = ((mae_raw - mae_kalman) / mae_raw) * 100 if mae_raw != 0 else 0\n",
    "        excellent_improvement = excellent_time_kalman - excellent_time_raw\n",
    "        poor_improvement = poor_time_raw - poor_time_kalman\n",
    "        \n",
    "        print(f\"  RMSE improvement: {rmse_improvement:+.1f}%\")\n",
    "        print(f\"  MAE improvement: {mae_improvement:+.1f}%\")\n",
    "        print(f\"  Excellent time improvement: {excellent_improvement:+.1f}%\")\n",
    "        print(f\"  Poor time reduction: {poor_improvement:+.1f}%\")\n",
    "        \n",
    "        print(f\"\\nANALISIS STEERING:\")\n",
    "        print(f\"  KALMAN FILTER:\")\n",
    "        print(f\"    Mean |steering|: {np.mean([abs(s) for s in active_steering_kalman]):.3f}\")\n",
    "        print(f\"    Std steering: {steering_smoothness_kalman:.3f}\")\n",
    "        print(f\"  RAW IMU:\")\n",
    "        print(f\"    Mean |steering|: {np.mean([abs(s) for s in active_steering_raw]):.3f}\")\n",
    "        print(f\"    Std steering: {steering_smoothness_raw:.3f}\")\n",
    "        print(f\"  Steering difference:\")\n",
    "        print(f\"    Mean difference: {np.mean(active_steering_diff):+.3f}\")\n",
    "        print(f\"    Max |difference|: {max([abs(d) for d in active_steering_diff]):.3f}\")\n",
    "        \n",
    "        smoothness_improvement = ((steering_smoothness_raw - steering_smoothness_kalman) / steering_smoothness_raw) * 100 if steering_smoothness_raw != 0 else 0\n",
    "        print(f\"    Smoothness improvement: {smoothness_improvement:+.1f}%\")\n",
    "        \n",
    "        print(f\"\\nKESIMPULAN:\")\n",
    "        kalman_wins = 0\n",
    "        if rmse_improvement > 0:\n",
    "            print(f\"  Kalman Filter: Lebih akurat\")\n",
    "            kalman_wins += 1\n",
    "        else:\n",
    "            print(f\"  Raw IMU: Lebih akurat\")\n",
    "            \n",
    "        if smoothness_improvement > 0:\n",
    "            print(f\"  Kalman Filter: Steering lebih smooth\")\n",
    "            kalman_wins += 1\n",
    "        else:\n",
    "            print(f\"  Raw IMU: Steering lebih smooth\")\n",
    "            \n",
    "        if excellent_improvement > 0:\n",
    "            print(f\"  Kalman Filter: Lebih stabil\")\n",
    "            kalman_wins += 1\n",
    "        else:\n",
    "            print(f\"  Raw IMU: Lebih stabil\")\n",
    "        \n",
    "        print(f\"\\nREKOMENDASI:\")\n",
    "        if kalman_wins >= 2:\n",
    "            print(f\"  KALMAN FILTER direkomendasikan\")\n",
    "            print(f\"  Unggul di {kalman_wins}/3 metrik utama\")\n",
    "        else:\n",
    "            print(f\"  RAW IMU kompetitif\")\n",
    "            print(f\"  Pertimbangkan tuning Kalman filter\")\n",
    "        \n",
    "        # Statistik akhir\n",
    "        print(f\"\\nSTATISTIK RINGKASAN:\")\n",
    "        print(f\"KALMAN FILTER:\")\n",
    "        print(f\"  Mean |Yaw Error|: {mae_kalman:.2f}°\")\n",
    "        print(f\"  Std Yaw Error: {np.std(active_errors_kalman):.2f}°\")\n",
    "        print(f\"  Mean |Yaw Rate|: {np.mean([abs(r) for r in active_yaw_rates_kalman]):.1f}°/s\")\n",
    "        print(f\"RAW IMU:\")\n",
    "        print(f\"  Mean |Yaw Error|: {mae_raw:.2f}°\")\n",
    "        print(f\"  Std Yaw Error: {np.std(active_errors_raw):.2f}°\")\n",
    "        print(f\"  Mean |Yaw Rate|: {np.mean([abs(r) for r in active_yaw_rates_raw]):.1f}°/s\")\n",
    "        print(f\"Total data points: {len(time_list)} ({len(active_indices)} active)\")\n",
    "\n",
    "def main():\n",
    "    \"\"\"Fungsi utama analisis\"\"\"\n",
    "    print(\"JetRacer Data Analysis Program\")\n",
    "    print(\"=\"*40)\n",
    "    \n",
    "    # Load data\n",
    "    data_log = load_data()\n",
    "    if data_log is None:\n",
    "        return\n",
    "    \n",
    "    # Buat plots\n",
    "    print(\"\\nMembuat plots...\")\n",
    "    plt_obj = create_plots(data_log)\n",
    "    \n",
    "    # Analisis performa\n",
    "    print(\"\\nMelakukan analisis performa...\")\n",
    "    analyze_performance(data_log)\n",
    "    \n",
    "    # Tampilkan plots\n",
    "    print(\"\\nMenampilkan plots...\")\n",
    "    plt_obj.show()\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
